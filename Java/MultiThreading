Multitasking

The execution of multiple tasks at the same time by the CPU is called as Multi Tasking. For eg when we run vlc and the same time
we run excel or browser or some other software.

MultiProcessing

The use of Multiple processors at the same time is called multiprocessing, this simply when multiple cpus are used by os
to perform a task.

MultiThreading
The process of executing multiple threads at the same time (executing subtasks or subprocess) is called multi threading.

for eg, when we run media player we can see many different tasks working at same time, such as timer bar, volume options etc
, that is all because of multi threading.

Why and Where do we need Multithreading

suppose we run a movie in media player, then there are two methods, run video and run audio, suppose we have to run normally
using main method, then we know 1st one will be executed first and then the next one, this is a major issue, so to solve this
we need both the methods to run at same time, this is where multi threading comes into play, with the help of multi threading
we can run multiple threads at same time and thus can play video and audio in form of threads at the same time.

Process vs Thread

Process = A program which is in execution state.
Context Switching = means when we run a program then the processes inside it do not work together same, they keep switching
in between, for eg we run process 1 vlc and process 2 browser, then we may think both are running together but it is due to
context switching which happens very fast.
Communication = communication between process takes long time
Address space = each process has different address space
Dependency = processes are not dependent on each others
Synchronization = no synchronization between processes.
Resource Consumption = More Resources are consumed
Time of Creation = More Time
Time of termination = More Time

Thread = It is subpart of process, eg vlc is thread then video playing is process
Context Switching = may or may not happen between threads, but is faster then switching between process
Communication = faster than process between threads
Address space, shares address space if threads are of same process
Dependency = Threads are dependent on each other
Synchronization = May or may not happen
Resource consumption = less resources consumed than process
Time of Creation = Less Time
Time of Termination = Less Time

Thread Class implements runnable Interface

LifeCycle of Thread :
To learn the lifecycle of thread, first we will see how we can create a thread

1. To create a thread we have to extend thread class or implement it's runnable interface
2. Second step is to override the run method
3. In the main method create a new thread
4. Now call the start method for the object of the thread

1.Now the first state is born state in which thread is born, this happens when we create object of thread
2.Second state is runnable state, state in which thread is ready to run, this happens when we call start
3.After calling start JVM will allocate a processor to thread, After this the thread calls the run method where we have
declared all the tasks it shall perform.
4.Fourth is the dead state where thread is completed and dead, remember once a thread is used it can't be used again.
5.Fifth state is non-runnable state, in this state the user can stop the thread for some time or longer
depending on the method it calls, this is defined in run method, user can call method such as sleep to stop running of
thread, or some other pre defined method such as suspend, waiting.

remember if we call run method instead of start first then thread will not work properly.

How to create a thread using thread class

class Test extends Thread {

@Override
public void run() {
some task
}

public static void main(String[] args) {
Test t = new Test();
t.start();//remember if we call t.run() it will not create the 1st thread rather just call the run method
}
}

How to create a thread using Runnable Interface

class Test implements Runnable {
@Override
public void run() {
some task
}

public static void main(String[] args) {
Test t = new Test();
Thread th = new Thread(t);
th.start();

How is this working?
when we create an object of test, and then create a thread object, then we can pass the test object in thread constructor
which take runnable object.

so this way we can use runnable
}
}

The question arises which is better, extending thread class looks easier, it is better to use runnable interface
because suppose there is class A which extends B, then since multiple inheritance is not allowed due to ambiguity,
so we will be unable to extend the thread class, but in this situation we can easily implement the runnable interface.


The above was example of single thread doing single task

Single task using multiple thread


public static void main(String[] args) {
Test t1 = new Test(); //Creation of main thread
t.start();//Creation of thread1
Test t2 = new Test();
t2.start();//Creation of thread2

It can be asked in interview in above how many threads are created, the answer is 3 as we can see above
}


Multiple Task using Single Thread
Not possible


Multiple Task using Multiple Thread

Simply create two class that extend thread and call them in main, or simply use two classes that implement runnable interface
and then create objects of both and initialize them in two different threads

class A extends Thread {
void run() {

}
}
class B extends Thread {
void run(){

}
}

A a = new A();
a.start();
B b = new B();
b.start();

In interview it can be asked which thread gets executed first, one might assume a will get executed first but that is
not the case, be it in Multiple Task using Multiple Thread or Single Task using Multiple Thread, the execution
of thread is done by JVM and is done using thread scheduling algos.
