1. WHAT IS SPRINGBOOT

SPRINGBOOT IS A MODULE OF SPRING WHICH PROVIDES RAD(RAPID APPLICATION DEVELOPMENT) TO THE SPRING FRAMEWORK, IT IS USED
TO CREATE STANDALONE SPRING BASED APPLICATION, THAT YOU CAN JUST RUN AS IT NEEDS VERY LITTLE CONFIGURATION.

ADVANTAGES

EMBED TOMCAT AND MANY OTHER JARS, IS PROVIDED WITH STARTER POM FOR HELPING IN MAVEN CONFIGURATION, AUTOMATICALLY CONFIGURES
SPRING WHEREVER POSSIBLE

FEATURES OF SPRINGBOOT
WEBDEVELOPMENT
SPRINGAPPLICATION
APPLICATION EVENTS AND LISTENERS
ADMIN FEATURES


THE @RESTCONTROLLER IS A STEREOTYPE ANNOTATION. IT ADDS @CONTROLLER AND @RESPONSEBODY ANNOTATIONS TO THE CLASS.
WE NEED TO IMPORT ORG.SPRINGFRAMEWORK.WEB.BIND.ANNOTATION PACKAGE IN OUR FILE, IN ORDER TO IMPLEMENT IT.

SPRING BOOT PROVIDES VARIOUS PROPERTIES WHICH CAN BE SPECIFIED INSIDE OUR PROJECT'S APPLICATION.PROPERTIES FILE.
THESE PROPERTIES HAVE DEFAULT VALUES AND YOU CAN SET THAT INSIDE THE PROPERTIES FILE. PROPERTIES ARE USED TO SET
VALUES LIKE: SERVER-PORT NUMBER, DATABASE CONNECTION CONFIGURATION ETC.

SPRINGBOOT PROVIDES BUILT IN STARTER WHICH MAKES DEVELOPMENT EASIER AND RAPID, FOR EG IF WE HAVE TO GET STARTED
USING SPRING AND JPA, JUST INCLUDE SPRING-BOOT-STARTER-DATA-JPA

SPRINGBOOT PROVIDES ACTUATOR TO MANAGE OUR APPLICATIONS. ACTUATOR IS A TOOL WHICH HAS HTTP ENDPOINTS, WHEN APPLICATION
IS PUSHED TO PRODUCTION WE CAN CHECK MONITOR OUR APPLICATION USING THESE HTTP ENDPOINTS

2. THYMELEAF = IT IS A SERVER SIDE JAVA TEMPLATE ENGINE FOR WEB APPLICATION. IT'S MAIN GOAL IS TO BRING ELEGANT NATURAL
 TEMPLATES TO YOUR WEB APPLICATION.
 IT CAN BE INTEGRATE WITH SPRING FRAMEWORK AND IDEAL FOR HTML5 JAVA WEB APPLICATIONS.

3. THE @SPRINGBOOTAPPLICATION ANNOTATION IS EQUIVALENT TO USING @CONFIGURATION, @ENABLEAUTOCONFIGURATION,
 AND @COMPONENTSCAN WITH THEIR DEFAULT ATTRIBUTES. SPRING BOOT ENABLES THE DEVELOPER TO USE A SINGLE ANNOTATION
 INSTEAD OF USING MULTIPLE. BUT, AS WE KNOW, SPRING PROVIDED LOOSELY COUPLED FEATURES THAT WE CAN USE FOR EACH
 ANNOTATION AS PER OUR PROJECT NEEDS

 @BEAN: IT IS A METHOD-LEVEL ANNOTATION. IT IS AN ALTERNATIVE OF XML <BEAN> TAG. IT TELLS THE METHOD TO PRODUCE A
 BEAN TO BE MANAGED BY SPRING CONTAINER.

 @COMPONENT: IT IS A CLASS-LEVEL ANNOTATION. IT IS USED TO MARK A JAVA CLASS AS A BEAN.

 @CONTROLLER: THE @CONTROLLER IS A CLASS-LEVEL ANNOTATION. IT IS A SPECIALIZATION OF @COMPONENT. IT MARKS A CLASS AS A
 WEB REQUEST HANDLER. IT IS OFTEN USED TO SERVE WEB PAGES. BY DEFAULT, IT RETURNS A STRING THAT INDICATES WHICH ROUTE
 TO REDIRECT. IT IS MOSTLY USED WITH @REQUESTMAPPING ANNOTATION.

 @REQUESTMAPPING: IT IS USED TO MAP THE WEB REQUESTS. IT HAS MANY OPTIONAL ELEMENTS LIKE CONSUMES, HEADER, METHOD, NAME,
  PARAMS, PATH, PRODUCES, AND VALUE. WE USE IT WITH THE CLASS AS WELL AS THE METHOD.

 @REPOSITORY: IT IS A CLASS-LEVEL ANNOTATION. THE REPOSITORY IS A DAOS (DATA ACCESS OBJECT) THAT ACCESS THE DATABASE DIRECTLY.
 THE REPOSITORY DOES ALL THE OPERATIONS RELATED TO THE DATABASE.

 @ENABLEAUTOCONFIGURATION – TO MAKE SPRING BOOT LOOK FOR AUTO-CONFIGURATION BEANS ON ITS CLASSPATH AND AUTOMATICALLY
 APPLY THEM.
 @SPRINGBOOTAPPLICATION – USED TO DENOTE THE MAIN CLASS OF A BOOT APPLICATION. THIS ANNOTATION COMBINES @CONFIGURATION,
 @ENABLEAUTOCONFIGURATION, AND @COMPONENTSCAN ANNOTATIONS WITH THEIR DEFAULT ATTRIBUTES.
 @SERVICE: IT IS ALSO USED AT CLASS LEVEL. IT TELLS THE SPRING THAT CLASS CONTAINS THE BUSINESS LOGIC.

 APPLICATIONCONTEXT IS AN INTERFACE FOR PROVIDING CONFIGURATION INFORMATION TO AN APPLICATION. THERE ARE MULTIPLE CLASSES
 PROVIDED BY SPRINGFRAMEWORK THAT IMPLEMENTS THIS INTERFACE AND HELPS US USE CONFIGURATION INFORMATION IN APPLICATIONS.
 APPLICATIONCONTEXT PROVIDES STANDARD BEAN FACTORY LIFECYCLE CAPABILITIES.

 THE @ENABLEAUTOCONFIGURATION ANNOTATION ENABLES SPRING BOOT TO AUTO-CONFIGURE THE APPLICATION CONTEXT. THEREFORE, IT
 AUTOMATICALLY CREATES AND REGISTERS BEANS BASED ON BOTH THE INCLUDED JAR FILES IN THE CLASSPATH AND THE BEANS
 DEFINED BY US.
 SPRING @CONFIGURATION ANNOTATION IS PART OF THE SPRING CORE FRAMEWORK. SPRING CONFIGURATION ANNOTATION INDICATES
 THAT THE CLASS HAS @BEAN DEFINITION METHODS.
 WHILE DEVELOPING AN APPLICATION, WE NEED TO TELL THE SPRING FRAMEWORK TO LOOK FOR SPRING-MANAGED COMPONENTS.

 @COMPONENTSCAN ENABLES SPRING TO SCAN FOR THINGS LIKE CONFIGURATIONS, CONTROLLERS, SERVICES, AND OTHER COMPONENTS WE DEFINE.

 @CONTROLLER MAP OF THE MODEL OBJECT TO VIEW OR TEMPLATE AND MAKE IT HUMAN READABLE BUT @RESTCONTROLLER SIMPLY
 RETURNS THE OBJECT AND OBJECT DATA IS DIRECTLY WRITTEN IN HTTP RESPONSE AS JSON OR XML.

 Dependency Injection
 Instead of creating a new object, spring instantiates this object
 AUTOWIRING FEATURE OF SPRING FRAMEWORK ENABLES YOU TO INJECT THE OBJECT DEPENDENCY IMPLICITLY.

 Bean
 Simply instance of class managed by spring container.

 Spring container
 The Spring container is at the core of the Spring Framework. The container will create the objects/beans, wire them together,
 configure them, and manage their complete life cycle from creation till destruction. The Spring container uses DI(dependency
 injection) to manage the components that make up an application.

 What is curl command?
 Client URL (cURL, pronounced “curl”) is a command line tool that enables data exchange between a device and a server
 through a terminal. Using this command line interface (CLI), a user specifies a server URL (the location where they
 want to send a request) and the data they want to send to that server URL.

 SpringApplication.run simply returns the object of application context

 @Component is a class-level annotation, but @Bean is at the method level, so @Component is only an option when a class's source code is editable.
 @Bean can always be used, but it's more verbose. @Component is compatible with Spring's auto-detection, but @Bean requires manual class instantiation.
 Bean works only when class is also annotated with @Configuration but Component does not require configuration.

 What is the difference between @bean and @configuration?
 @Configuration - It is like beans. xml but Java-based bean configuration. It means class annotated with this annotation is the place where beans are
 configured and will be a candidate for auto-detection. In this class, methods are annotated with @Bean which return an object of the class.

 Bean Lifecycle

 Container started -> bean instantiated -> @post construct annotation with method(eg db connection on) ->
 further methods -> @predestroy annotation with method(db connection close)

 ApplicationContext represents the Spring IoC(Inversion of Control) container and is responsible for instantiating,
 configuring, and assembling the aforementioned beans.The container gets its instructions on what objects to instantiate,
 configure, and assemble by reading configuration metadata.

 Spring provides further stereotype annotations: @Component, @Service, and @Controller. @Component is a generic stereotype for any Spring-managed component.
 @Repository, @Service, and @Controller are specializations of @Component for more specific use cases (in the persistence, service, and presentation layers,
 respectively). Therefore, you can annotate your component classes with @Component, but,
 by annotating them with @Repository, @Service, or @Controller instead, your classes are more properly suited for processing by tools or associating with aspects.

 For example, these stereotype annotations make ideal targets for pointcuts. @Repository, @Service, and @Controller can also carry additional
 semantics in future releases of the Spring Framework. Thus, if you are choosing between using @Component or @Service for your service layer,
 @Service is clearly the better choice. Similarly, as stated earlier, @Repository is already supported as a marker for automatic exception
 translation in your persistence layer.

Spring bean scopes

These are of 5 types

singleton - only one instance of the spring bean will be created for the spring container. This is the default
spring bean scope. While using this scope, make sure bean doesn’t have shared instance variables otherwise it
might lead to data inconsistency issues.

prototype – A new instance will be created every time the bean is requested from the spring container.

request – This is same as prototype scope, however it’s meant to be used for web applications. A new instance of the
bean will be created for each HTTP request.

session – A new bean will be created for each HTTP session by the container.
global-session – This is used to create global session beans for Portlet applications.

Spring IoC is the mechanism to achieve loose-coupling between Objects dependencies. To achieve loose
coupling and dynamic binding of the objects at runtime, objects dependencies are injected by other assembler objects.

Inversion of Control
The IoC container is responsible to instantiate, configure and assemble the objects. The IoC container gets
informations from the XML file and works accordingly.

The main tasks performed by IoC container are:

to instantiate the application class
to configure the object
to assemble the dependencies between the objects
There are two types of IoC containers. They are:

BeanFactory
ApplicationContext

The org.springframework.beans.factory.BeanFactory and the org.springframework.context.ApplicationContext interfaces
acts as the IoC container. The ApplicationContext interface is built on top of the BeanFactory interface.
It adds some extra functionality than BeanFactory such as simple integration with Spring's AOP, message
resource handling (for I18N), event propagation, application layer specific context
(e.g. WebApplicationContext) for web application. So it is better to use ApplicationContext than BeanFactory.

Spring @Autowired annotation is used for automatic dependency injection. Spring framework is built on
dependency injection and we inject the class dependencies through spring bean configuration file

Spring Boot actuator has number of features, it is used to help you monitor your application when you push it to
production, you can choose to manage and monitor your application by using http endpoints, or with jmx, auditing
health, and metrics gathering, can also be automatically aligned to application.